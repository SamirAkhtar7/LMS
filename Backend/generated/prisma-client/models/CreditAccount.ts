
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CreditAccount` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model CreditAccount
 * 
 */
export type CreditAccountModel = runtime.Types.Result.DefaultSelection<Prisma.$CreditAccountPayload>

export type AggregateCreditAccount = {
  _count: CreditAccountCountAggregateOutputType | null
  _avg: CreditAccountAvgAggregateOutputType | null
  _sum: CreditAccountSumAggregateOutputType | null
  _min: CreditAccountMinAggregateOutputType | null
  _max: CreditAccountMaxAggregateOutputType | null
}

export type CreditAccountAvgAggregateOutputType = {
  sanctionedAmount: number | null
  outstanding: number | null
  emiAmount: number | null
  dpd: number | null
}

export type CreditAccountSumAggregateOutputType = {
  sanctionedAmount: number | null
  outstanding: number | null
  emiAmount: number | null
  dpd: number | null
}

export type CreditAccountMinAggregateOutputType = {
  id: string | null
  creditReportId: string | null
  lenderName: string | null
  accountType: string | null
  accountStatus: string | null
  sanctionedAmount: number | null
  outstanding: number | null
  emiAmount: number | null
  dpd: number | null
  openedDate: Date | null
  closedDate: Date | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type CreditAccountMaxAggregateOutputType = {
  id: string | null
  creditReportId: string | null
  lenderName: string | null
  accountType: string | null
  accountStatus: string | null
  sanctionedAmount: number | null
  outstanding: number | null
  emiAmount: number | null
  dpd: number | null
  openedDate: Date | null
  closedDate: Date | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type CreditAccountCountAggregateOutputType = {
  id: number
  creditReportId: number
  lenderName: number
  accountType: number
  accountStatus: number
  sanctionedAmount: number
  outstanding: number
  emiAmount: number
  dpd: number
  openedDate: number
  closedDate: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type CreditAccountAvgAggregateInputType = {
  sanctionedAmount?: true
  outstanding?: true
  emiAmount?: true
  dpd?: true
}

export type CreditAccountSumAggregateInputType = {
  sanctionedAmount?: true
  outstanding?: true
  emiAmount?: true
  dpd?: true
}

export type CreditAccountMinAggregateInputType = {
  id?: true
  creditReportId?: true
  lenderName?: true
  accountType?: true
  accountStatus?: true
  sanctionedAmount?: true
  outstanding?: true
  emiAmount?: true
  dpd?: true
  openedDate?: true
  closedDate?: true
  createdAt?: true
  updatedAt?: true
}

export type CreditAccountMaxAggregateInputType = {
  id?: true
  creditReportId?: true
  lenderName?: true
  accountType?: true
  accountStatus?: true
  sanctionedAmount?: true
  outstanding?: true
  emiAmount?: true
  dpd?: true
  openedDate?: true
  closedDate?: true
  createdAt?: true
  updatedAt?: true
}

export type CreditAccountCountAggregateInputType = {
  id?: true
  creditReportId?: true
  lenderName?: true
  accountType?: true
  accountStatus?: true
  sanctionedAmount?: true
  outstanding?: true
  emiAmount?: true
  dpd?: true
  openedDate?: true
  closedDate?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type CreditAccountAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CreditAccount to aggregate.
   */
  where?: Prisma.CreditAccountWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CreditAccounts to fetch.
   */
  orderBy?: Prisma.CreditAccountOrderByWithRelationInput | Prisma.CreditAccountOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CreditAccountWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CreditAccounts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CreditAccounts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned CreditAccounts
  **/
  _count?: true | CreditAccountCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: CreditAccountAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: CreditAccountSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CreditAccountMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CreditAccountMaxAggregateInputType
}

export type GetCreditAccountAggregateType<T extends CreditAccountAggregateArgs> = {
      [P in keyof T & keyof AggregateCreditAccount]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateCreditAccount[P]>
    : Prisma.GetScalarType<T[P], AggregateCreditAccount[P]>
}




export type CreditAccountGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CreditAccountWhereInput
  orderBy?: Prisma.CreditAccountOrderByWithAggregationInput | Prisma.CreditAccountOrderByWithAggregationInput[]
  by: Prisma.CreditAccountScalarFieldEnum[] | Prisma.CreditAccountScalarFieldEnum
  having?: Prisma.CreditAccountScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CreditAccountCountAggregateInputType | true
  _avg?: CreditAccountAvgAggregateInputType
  _sum?: CreditAccountSumAggregateInputType
  _min?: CreditAccountMinAggregateInputType
  _max?: CreditAccountMaxAggregateInputType
}

export type CreditAccountGroupByOutputType = {
  id: string
  creditReportId: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount: number | null
  outstanding: number | null
  emiAmount: number | null
  dpd: number | null
  openedDate: Date | null
  closedDate: Date | null
  createdAt: Date
  updatedAt: Date
  _count: CreditAccountCountAggregateOutputType | null
  _avg: CreditAccountAvgAggregateOutputType | null
  _sum: CreditAccountSumAggregateOutputType | null
  _min: CreditAccountMinAggregateOutputType | null
  _max: CreditAccountMaxAggregateOutputType | null
}

type GetCreditAccountGroupByPayload<T extends CreditAccountGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CreditAccountGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CreditAccountGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CreditAccountGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CreditAccountGroupByOutputType[P]>
      }
    >
  >



export type CreditAccountWhereInput = {
  AND?: Prisma.CreditAccountWhereInput | Prisma.CreditAccountWhereInput[]
  OR?: Prisma.CreditAccountWhereInput[]
  NOT?: Prisma.CreditAccountWhereInput | Prisma.CreditAccountWhereInput[]
  id?: Prisma.StringFilter<"CreditAccount"> | string
  creditReportId?: Prisma.StringFilter<"CreditAccount"> | string
  lenderName?: Prisma.StringFilter<"CreditAccount"> | string
  accountType?: Prisma.StringFilter<"CreditAccount"> | string
  accountStatus?: Prisma.StringFilter<"CreditAccount"> | string
  sanctionedAmount?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  outstanding?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  emiAmount?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  dpd?: Prisma.IntNullableFilter<"CreditAccount"> | number | null
  openedDate?: Prisma.DateTimeNullableFilter<"CreditAccount"> | Date | string | null
  closedDate?: Prisma.DateTimeNullableFilter<"CreditAccount"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"CreditAccount"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CreditAccount"> | Date | string
  creditReport?: Prisma.XOR<Prisma.CreditReportScalarRelationFilter, Prisma.CreditReportWhereInput>
}

export type CreditAccountOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  creditReportId?: Prisma.SortOrder
  lenderName?: Prisma.SortOrder
  accountType?: Prisma.SortOrder
  accountStatus?: Prisma.SortOrder
  sanctionedAmount?: Prisma.SortOrderInput | Prisma.SortOrder
  outstanding?: Prisma.SortOrderInput | Prisma.SortOrder
  emiAmount?: Prisma.SortOrderInput | Prisma.SortOrder
  dpd?: Prisma.SortOrderInput | Prisma.SortOrder
  openedDate?: Prisma.SortOrderInput | Prisma.SortOrder
  closedDate?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  creditReport?: Prisma.CreditReportOrderByWithRelationInput
  _relevance?: Prisma.CreditAccountOrderByRelevanceInput
}

export type CreditAccountWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.CreditAccountWhereInput | Prisma.CreditAccountWhereInput[]
  OR?: Prisma.CreditAccountWhereInput[]
  NOT?: Prisma.CreditAccountWhereInput | Prisma.CreditAccountWhereInput[]
  creditReportId?: Prisma.StringFilter<"CreditAccount"> | string
  lenderName?: Prisma.StringFilter<"CreditAccount"> | string
  accountType?: Prisma.StringFilter<"CreditAccount"> | string
  accountStatus?: Prisma.StringFilter<"CreditAccount"> | string
  sanctionedAmount?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  outstanding?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  emiAmount?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  dpd?: Prisma.IntNullableFilter<"CreditAccount"> | number | null
  openedDate?: Prisma.DateTimeNullableFilter<"CreditAccount"> | Date | string | null
  closedDate?: Prisma.DateTimeNullableFilter<"CreditAccount"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"CreditAccount"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CreditAccount"> | Date | string
  creditReport?: Prisma.XOR<Prisma.CreditReportScalarRelationFilter, Prisma.CreditReportWhereInput>
}, "id">

export type CreditAccountOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  creditReportId?: Prisma.SortOrder
  lenderName?: Prisma.SortOrder
  accountType?: Prisma.SortOrder
  accountStatus?: Prisma.SortOrder
  sanctionedAmount?: Prisma.SortOrderInput | Prisma.SortOrder
  outstanding?: Prisma.SortOrderInput | Prisma.SortOrder
  emiAmount?: Prisma.SortOrderInput | Prisma.SortOrder
  dpd?: Prisma.SortOrderInput | Prisma.SortOrder
  openedDate?: Prisma.SortOrderInput | Prisma.SortOrder
  closedDate?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.CreditAccountCountOrderByAggregateInput
  _avg?: Prisma.CreditAccountAvgOrderByAggregateInput
  _max?: Prisma.CreditAccountMaxOrderByAggregateInput
  _min?: Prisma.CreditAccountMinOrderByAggregateInput
  _sum?: Prisma.CreditAccountSumOrderByAggregateInput
}

export type CreditAccountScalarWhereWithAggregatesInput = {
  AND?: Prisma.CreditAccountScalarWhereWithAggregatesInput | Prisma.CreditAccountScalarWhereWithAggregatesInput[]
  OR?: Prisma.CreditAccountScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CreditAccountScalarWhereWithAggregatesInput | Prisma.CreditAccountScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"CreditAccount"> | string
  creditReportId?: Prisma.StringWithAggregatesFilter<"CreditAccount"> | string
  lenderName?: Prisma.StringWithAggregatesFilter<"CreditAccount"> | string
  accountType?: Prisma.StringWithAggregatesFilter<"CreditAccount"> | string
  accountStatus?: Prisma.StringWithAggregatesFilter<"CreditAccount"> | string
  sanctionedAmount?: Prisma.FloatNullableWithAggregatesFilter<"CreditAccount"> | number | null
  outstanding?: Prisma.FloatNullableWithAggregatesFilter<"CreditAccount"> | number | null
  emiAmount?: Prisma.FloatNullableWithAggregatesFilter<"CreditAccount"> | number | null
  dpd?: Prisma.IntNullableWithAggregatesFilter<"CreditAccount"> | number | null
  openedDate?: Prisma.DateTimeNullableWithAggregatesFilter<"CreditAccount"> | Date | string | null
  closedDate?: Prisma.DateTimeNullableWithAggregatesFilter<"CreditAccount"> | Date | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"CreditAccount"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"CreditAccount"> | Date | string
}

export type CreditAccountCreateInput = {
  id?: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount?: number | null
  outstanding?: number | null
  emiAmount?: number | null
  dpd?: number | null
  openedDate?: Date | string | null
  closedDate?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
  creditReport: Prisma.CreditReportCreateNestedOneWithoutCreditAccountInput
}

export type CreditAccountUncheckedCreateInput = {
  id?: string
  creditReportId: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount?: number | null
  outstanding?: number | null
  emiAmount?: number | null
  dpd?: number | null
  openedDate?: Date | string | null
  closedDate?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CreditAccountUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  creditReport?: Prisma.CreditReportUpdateOneRequiredWithoutCreditAccountNestedInput
}

export type CreditAccountUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  creditReportId?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CreditAccountCreateManyInput = {
  id?: string
  creditReportId: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount?: number | null
  outstanding?: number | null
  emiAmount?: number | null
  dpd?: number | null
  openedDate?: Date | string | null
  closedDate?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CreditAccountUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CreditAccountUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  creditReportId?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CreditAccountListRelationFilter = {
  every?: Prisma.CreditAccountWhereInput
  some?: Prisma.CreditAccountWhereInput
  none?: Prisma.CreditAccountWhereInput
}

export type CreditAccountOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CreditAccountOrderByRelevanceInput = {
  fields: Prisma.CreditAccountOrderByRelevanceFieldEnum | Prisma.CreditAccountOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type CreditAccountCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  creditReportId?: Prisma.SortOrder
  lenderName?: Prisma.SortOrder
  accountType?: Prisma.SortOrder
  accountStatus?: Prisma.SortOrder
  sanctionedAmount?: Prisma.SortOrder
  outstanding?: Prisma.SortOrder
  emiAmount?: Prisma.SortOrder
  dpd?: Prisma.SortOrder
  openedDate?: Prisma.SortOrder
  closedDate?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CreditAccountAvgOrderByAggregateInput = {
  sanctionedAmount?: Prisma.SortOrder
  outstanding?: Prisma.SortOrder
  emiAmount?: Prisma.SortOrder
  dpd?: Prisma.SortOrder
}

export type CreditAccountMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  creditReportId?: Prisma.SortOrder
  lenderName?: Prisma.SortOrder
  accountType?: Prisma.SortOrder
  accountStatus?: Prisma.SortOrder
  sanctionedAmount?: Prisma.SortOrder
  outstanding?: Prisma.SortOrder
  emiAmount?: Prisma.SortOrder
  dpd?: Prisma.SortOrder
  openedDate?: Prisma.SortOrder
  closedDate?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CreditAccountMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  creditReportId?: Prisma.SortOrder
  lenderName?: Prisma.SortOrder
  accountType?: Prisma.SortOrder
  accountStatus?: Prisma.SortOrder
  sanctionedAmount?: Prisma.SortOrder
  outstanding?: Prisma.SortOrder
  emiAmount?: Prisma.SortOrder
  dpd?: Prisma.SortOrder
  openedDate?: Prisma.SortOrder
  closedDate?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type CreditAccountSumOrderByAggregateInput = {
  sanctionedAmount?: Prisma.SortOrder
  outstanding?: Prisma.SortOrder
  emiAmount?: Prisma.SortOrder
  dpd?: Prisma.SortOrder
}

export type CreditAccountCreateNestedManyWithoutCreditReportInput = {
  create?: Prisma.XOR<Prisma.CreditAccountCreateWithoutCreditReportInput, Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput> | Prisma.CreditAccountCreateWithoutCreditReportInput[] | Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput[]
  connectOrCreate?: Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput | Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput[]
  createMany?: Prisma.CreditAccountCreateManyCreditReportInputEnvelope
  connect?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
}

export type CreditAccountUncheckedCreateNestedManyWithoutCreditReportInput = {
  create?: Prisma.XOR<Prisma.CreditAccountCreateWithoutCreditReportInput, Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput> | Prisma.CreditAccountCreateWithoutCreditReportInput[] | Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput[]
  connectOrCreate?: Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput | Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput[]
  createMany?: Prisma.CreditAccountCreateManyCreditReportInputEnvelope
  connect?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
}

export type CreditAccountUpdateManyWithoutCreditReportNestedInput = {
  create?: Prisma.XOR<Prisma.CreditAccountCreateWithoutCreditReportInput, Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput> | Prisma.CreditAccountCreateWithoutCreditReportInput[] | Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput[]
  connectOrCreate?: Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput | Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput[]
  upsert?: Prisma.CreditAccountUpsertWithWhereUniqueWithoutCreditReportInput | Prisma.CreditAccountUpsertWithWhereUniqueWithoutCreditReportInput[]
  createMany?: Prisma.CreditAccountCreateManyCreditReportInputEnvelope
  set?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  disconnect?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  delete?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  connect?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  update?: Prisma.CreditAccountUpdateWithWhereUniqueWithoutCreditReportInput | Prisma.CreditAccountUpdateWithWhereUniqueWithoutCreditReportInput[]
  updateMany?: Prisma.CreditAccountUpdateManyWithWhereWithoutCreditReportInput | Prisma.CreditAccountUpdateManyWithWhereWithoutCreditReportInput[]
  deleteMany?: Prisma.CreditAccountScalarWhereInput | Prisma.CreditAccountScalarWhereInput[]
}

export type CreditAccountUncheckedUpdateManyWithoutCreditReportNestedInput = {
  create?: Prisma.XOR<Prisma.CreditAccountCreateWithoutCreditReportInput, Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput> | Prisma.CreditAccountCreateWithoutCreditReportInput[] | Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput[]
  connectOrCreate?: Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput | Prisma.CreditAccountCreateOrConnectWithoutCreditReportInput[]
  upsert?: Prisma.CreditAccountUpsertWithWhereUniqueWithoutCreditReportInput | Prisma.CreditAccountUpsertWithWhereUniqueWithoutCreditReportInput[]
  createMany?: Prisma.CreditAccountCreateManyCreditReportInputEnvelope
  set?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  disconnect?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  delete?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  connect?: Prisma.CreditAccountWhereUniqueInput | Prisma.CreditAccountWhereUniqueInput[]
  update?: Prisma.CreditAccountUpdateWithWhereUniqueWithoutCreditReportInput | Prisma.CreditAccountUpdateWithWhereUniqueWithoutCreditReportInput[]
  updateMany?: Prisma.CreditAccountUpdateManyWithWhereWithoutCreditReportInput | Prisma.CreditAccountUpdateManyWithWhereWithoutCreditReportInput[]
  deleteMany?: Prisma.CreditAccountScalarWhereInput | Prisma.CreditAccountScalarWhereInput[]
}

export type CreditAccountCreateWithoutCreditReportInput = {
  id?: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount?: number | null
  outstanding?: number | null
  emiAmount?: number | null
  dpd?: number | null
  openedDate?: Date | string | null
  closedDate?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CreditAccountUncheckedCreateWithoutCreditReportInput = {
  id?: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount?: number | null
  outstanding?: number | null
  emiAmount?: number | null
  dpd?: number | null
  openedDate?: Date | string | null
  closedDate?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CreditAccountCreateOrConnectWithoutCreditReportInput = {
  where: Prisma.CreditAccountWhereUniqueInput
  create: Prisma.XOR<Prisma.CreditAccountCreateWithoutCreditReportInput, Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput>
}

export type CreditAccountCreateManyCreditReportInputEnvelope = {
  data: Prisma.CreditAccountCreateManyCreditReportInput | Prisma.CreditAccountCreateManyCreditReportInput[]
  skipDuplicates?: boolean
}

export type CreditAccountUpsertWithWhereUniqueWithoutCreditReportInput = {
  where: Prisma.CreditAccountWhereUniqueInput
  update: Prisma.XOR<Prisma.CreditAccountUpdateWithoutCreditReportInput, Prisma.CreditAccountUncheckedUpdateWithoutCreditReportInput>
  create: Prisma.XOR<Prisma.CreditAccountCreateWithoutCreditReportInput, Prisma.CreditAccountUncheckedCreateWithoutCreditReportInput>
}

export type CreditAccountUpdateWithWhereUniqueWithoutCreditReportInput = {
  where: Prisma.CreditAccountWhereUniqueInput
  data: Prisma.XOR<Prisma.CreditAccountUpdateWithoutCreditReportInput, Prisma.CreditAccountUncheckedUpdateWithoutCreditReportInput>
}

export type CreditAccountUpdateManyWithWhereWithoutCreditReportInput = {
  where: Prisma.CreditAccountScalarWhereInput
  data: Prisma.XOR<Prisma.CreditAccountUpdateManyMutationInput, Prisma.CreditAccountUncheckedUpdateManyWithoutCreditReportInput>
}

export type CreditAccountScalarWhereInput = {
  AND?: Prisma.CreditAccountScalarWhereInput | Prisma.CreditAccountScalarWhereInput[]
  OR?: Prisma.CreditAccountScalarWhereInput[]
  NOT?: Prisma.CreditAccountScalarWhereInput | Prisma.CreditAccountScalarWhereInput[]
  id?: Prisma.StringFilter<"CreditAccount"> | string
  creditReportId?: Prisma.StringFilter<"CreditAccount"> | string
  lenderName?: Prisma.StringFilter<"CreditAccount"> | string
  accountType?: Prisma.StringFilter<"CreditAccount"> | string
  accountStatus?: Prisma.StringFilter<"CreditAccount"> | string
  sanctionedAmount?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  outstanding?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  emiAmount?: Prisma.FloatNullableFilter<"CreditAccount"> | number | null
  dpd?: Prisma.IntNullableFilter<"CreditAccount"> | number | null
  openedDate?: Prisma.DateTimeNullableFilter<"CreditAccount"> | Date | string | null
  closedDate?: Prisma.DateTimeNullableFilter<"CreditAccount"> | Date | string | null
  createdAt?: Prisma.DateTimeFilter<"CreditAccount"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"CreditAccount"> | Date | string
}

export type CreditAccountCreateManyCreditReportInput = {
  id?: string
  lenderName: string
  accountType: string
  accountStatus: string
  sanctionedAmount?: number | null
  outstanding?: number | null
  emiAmount?: number | null
  dpd?: number | null
  openedDate?: Date | string | null
  closedDate?: Date | string | null
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type CreditAccountUpdateWithoutCreditReportInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CreditAccountUncheckedUpdateWithoutCreditReportInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CreditAccountUncheckedUpdateManyWithoutCreditReportInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  lenderName?: Prisma.StringFieldUpdateOperationsInput | string
  accountType?: Prisma.StringFieldUpdateOperationsInput | string
  accountStatus?: Prisma.StringFieldUpdateOperationsInput | string
  sanctionedAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  outstanding?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  emiAmount?: Prisma.NullableFloatFieldUpdateOperationsInput | number | null
  dpd?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  openedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  closedDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type CreditAccountSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  creditReportId?: boolean
  lenderName?: boolean
  accountType?: boolean
  accountStatus?: boolean
  sanctionedAmount?: boolean
  outstanding?: boolean
  emiAmount?: boolean
  dpd?: boolean
  openedDate?: boolean
  closedDate?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  creditReport?: boolean | Prisma.CreditReportDefaultArgs<ExtArgs>
}, ExtArgs["result"]["creditAccount"]>



export type CreditAccountSelectScalar = {
  id?: boolean
  creditReportId?: boolean
  lenderName?: boolean
  accountType?: boolean
  accountStatus?: boolean
  sanctionedAmount?: boolean
  outstanding?: boolean
  emiAmount?: boolean
  dpd?: boolean
  openedDate?: boolean
  closedDate?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type CreditAccountOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "creditReportId" | "lenderName" | "accountType" | "accountStatus" | "sanctionedAmount" | "outstanding" | "emiAmount" | "dpd" | "openedDate" | "closedDate" | "createdAt" | "updatedAt", ExtArgs["result"]["creditAccount"]>
export type CreditAccountInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  creditReport?: boolean | Prisma.CreditReportDefaultArgs<ExtArgs>
}

export type $CreditAccountPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "CreditAccount"
  objects: {
    creditReport: Prisma.$CreditReportPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    creditReportId: string
    lenderName: string
    accountType: string
    accountStatus: string
    sanctionedAmount: number | null
    outstanding: number | null
    emiAmount: number | null
    dpd: number | null
    openedDate: Date | null
    closedDate: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["creditAccount"]>
  composites: {}
}

export type CreditAccountGetPayload<S extends boolean | null | undefined | CreditAccountDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload, S>

export type CreditAccountCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CreditAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CreditAccountCountAggregateInputType | true
  }

export interface CreditAccountDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditAccount'], meta: { name: 'CreditAccount' } }
  /**
   * Find zero or one CreditAccount that matches the filter.
   * @param {CreditAccountFindUniqueArgs} args - Arguments to find a CreditAccount
   * @example
   * // Get one CreditAccount
   * const creditAccount = await prisma.creditAccount.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CreditAccountFindUniqueArgs>(args: Prisma.SelectSubset<T, CreditAccountFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one CreditAccount that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CreditAccountFindUniqueOrThrowArgs} args - Arguments to find a CreditAccount
   * @example
   * // Get one CreditAccount
   * const creditAccount = await prisma.creditAccount.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CreditAccountFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CreditAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CreditAccount that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountFindFirstArgs} args - Arguments to find a CreditAccount
   * @example
   * // Get one CreditAccount
   * const creditAccount = await prisma.creditAccount.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CreditAccountFindFirstArgs>(args?: Prisma.SelectSubset<T, CreditAccountFindFirstArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CreditAccount that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountFindFirstOrThrowArgs} args - Arguments to find a CreditAccount
   * @example
   * // Get one CreditAccount
   * const creditAccount = await prisma.creditAccount.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CreditAccountFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CreditAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more CreditAccounts that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CreditAccounts
   * const creditAccounts = await prisma.creditAccount.findMany()
   * 
   * // Get first 10 CreditAccounts
   * const creditAccounts = await prisma.creditAccount.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const creditAccountWithIdOnly = await prisma.creditAccount.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CreditAccountFindManyArgs>(args?: Prisma.SelectSubset<T, CreditAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a CreditAccount.
   * @param {CreditAccountCreateArgs} args - Arguments to create a CreditAccount.
   * @example
   * // Create one CreditAccount
   * const CreditAccount = await prisma.creditAccount.create({
   *   data: {
   *     // ... data to create a CreditAccount
   *   }
   * })
   * 
   */
  create<T extends CreditAccountCreateArgs>(args: Prisma.SelectSubset<T, CreditAccountCreateArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many CreditAccounts.
   * @param {CreditAccountCreateManyArgs} args - Arguments to create many CreditAccounts.
   * @example
   * // Create many CreditAccounts
   * const creditAccount = await prisma.creditAccount.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CreditAccountCreateManyArgs>(args?: Prisma.SelectSubset<T, CreditAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a CreditAccount.
   * @param {CreditAccountDeleteArgs} args - Arguments to delete one CreditAccount.
   * @example
   * // Delete one CreditAccount
   * const CreditAccount = await prisma.creditAccount.delete({
   *   where: {
   *     // ... filter to delete one CreditAccount
   *   }
   * })
   * 
   */
  delete<T extends CreditAccountDeleteArgs>(args: Prisma.SelectSubset<T, CreditAccountDeleteArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one CreditAccount.
   * @param {CreditAccountUpdateArgs} args - Arguments to update one CreditAccount.
   * @example
   * // Update one CreditAccount
   * const creditAccount = await prisma.creditAccount.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CreditAccountUpdateArgs>(args: Prisma.SelectSubset<T, CreditAccountUpdateArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more CreditAccounts.
   * @param {CreditAccountDeleteManyArgs} args - Arguments to filter CreditAccounts to delete.
   * @example
   * // Delete a few CreditAccounts
   * const { count } = await prisma.creditAccount.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CreditAccountDeleteManyArgs>(args?: Prisma.SelectSubset<T, CreditAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CreditAccounts.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CreditAccounts
   * const creditAccount = await prisma.creditAccount.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CreditAccountUpdateManyArgs>(args: Prisma.SelectSubset<T, CreditAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one CreditAccount.
   * @param {CreditAccountUpsertArgs} args - Arguments to update or create a CreditAccount.
   * @example
   * // Update or create a CreditAccount
   * const creditAccount = await prisma.creditAccount.upsert({
   *   create: {
   *     // ... data to create a CreditAccount
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CreditAccount we want to update
   *   }
   * })
   */
  upsert<T extends CreditAccountUpsertArgs>(args: Prisma.SelectSubset<T, CreditAccountUpsertArgs<ExtArgs>>): Prisma.Prisma__CreditAccountClient<runtime.Types.Result.GetResult<Prisma.$CreditAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of CreditAccounts.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountCountArgs} args - Arguments to filter CreditAccounts to count.
   * @example
   * // Count the number of CreditAccounts
   * const count = await prisma.creditAccount.count({
   *   where: {
   *     // ... the filter for the CreditAccounts we want to count
   *   }
   * })
  **/
  count<T extends CreditAccountCountArgs>(
    args?: Prisma.Subset<T, CreditAccountCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CreditAccountCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a CreditAccount.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CreditAccountAggregateArgs>(args: Prisma.Subset<T, CreditAccountAggregateArgs>): Prisma.PrismaPromise<GetCreditAccountAggregateType<T>>

  /**
   * Group by CreditAccount.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CreditAccountGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CreditAccountGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CreditAccountGroupByArgs['orderBy'] }
      : { orderBy?: CreditAccountGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CreditAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the CreditAccount model
 */
readonly fields: CreditAccountFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CreditAccount.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CreditAccountClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  creditReport<T extends Prisma.CreditReportDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CreditReportDefaultArgs<ExtArgs>>): Prisma.Prisma__CreditReportClient<runtime.Types.Result.GetResult<Prisma.$CreditReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the CreditAccount model
 */
export interface CreditAccountFieldRefs {
  readonly id: Prisma.FieldRef<"CreditAccount", 'String'>
  readonly creditReportId: Prisma.FieldRef<"CreditAccount", 'String'>
  readonly lenderName: Prisma.FieldRef<"CreditAccount", 'String'>
  readonly accountType: Prisma.FieldRef<"CreditAccount", 'String'>
  readonly accountStatus: Prisma.FieldRef<"CreditAccount", 'String'>
  readonly sanctionedAmount: Prisma.FieldRef<"CreditAccount", 'Float'>
  readonly outstanding: Prisma.FieldRef<"CreditAccount", 'Float'>
  readonly emiAmount: Prisma.FieldRef<"CreditAccount", 'Float'>
  readonly dpd: Prisma.FieldRef<"CreditAccount", 'Int'>
  readonly openedDate: Prisma.FieldRef<"CreditAccount", 'DateTime'>
  readonly closedDate: Prisma.FieldRef<"CreditAccount", 'DateTime'>
  readonly createdAt: Prisma.FieldRef<"CreditAccount", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"CreditAccount", 'DateTime'>
}
    

// Custom InputTypes
/**
 * CreditAccount findUnique
 */
export type CreditAccountFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * Filter, which CreditAccount to fetch.
   */
  where: Prisma.CreditAccountWhereUniqueInput
}

/**
 * CreditAccount findUniqueOrThrow
 */
export type CreditAccountFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * Filter, which CreditAccount to fetch.
   */
  where: Prisma.CreditAccountWhereUniqueInput
}

/**
 * CreditAccount findFirst
 */
export type CreditAccountFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * Filter, which CreditAccount to fetch.
   */
  where?: Prisma.CreditAccountWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CreditAccounts to fetch.
   */
  orderBy?: Prisma.CreditAccountOrderByWithRelationInput | Prisma.CreditAccountOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CreditAccounts.
   */
  cursor?: Prisma.CreditAccountWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CreditAccounts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CreditAccounts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CreditAccounts.
   */
  distinct?: Prisma.CreditAccountScalarFieldEnum | Prisma.CreditAccountScalarFieldEnum[]
}

/**
 * CreditAccount findFirstOrThrow
 */
export type CreditAccountFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * Filter, which CreditAccount to fetch.
   */
  where?: Prisma.CreditAccountWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CreditAccounts to fetch.
   */
  orderBy?: Prisma.CreditAccountOrderByWithRelationInput | Prisma.CreditAccountOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CreditAccounts.
   */
  cursor?: Prisma.CreditAccountWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CreditAccounts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CreditAccounts.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CreditAccounts.
   */
  distinct?: Prisma.CreditAccountScalarFieldEnum | Prisma.CreditAccountScalarFieldEnum[]
}

/**
 * CreditAccount findMany
 */
export type CreditAccountFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * Filter, which CreditAccounts to fetch.
   */
  where?: Prisma.CreditAccountWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CreditAccounts to fetch.
   */
  orderBy?: Prisma.CreditAccountOrderByWithRelationInput | Prisma.CreditAccountOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing CreditAccounts.
   */
  cursor?: Prisma.CreditAccountWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CreditAccounts from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CreditAccounts.
   */
  skip?: number
  distinct?: Prisma.CreditAccountScalarFieldEnum | Prisma.CreditAccountScalarFieldEnum[]
}

/**
 * CreditAccount create
 */
export type CreditAccountCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * The data needed to create a CreditAccount.
   */
  data: Prisma.XOR<Prisma.CreditAccountCreateInput, Prisma.CreditAccountUncheckedCreateInput>
}

/**
 * CreditAccount createMany
 */
export type CreditAccountCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many CreditAccounts.
   */
  data: Prisma.CreditAccountCreateManyInput | Prisma.CreditAccountCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * CreditAccount update
 */
export type CreditAccountUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * The data needed to update a CreditAccount.
   */
  data: Prisma.XOR<Prisma.CreditAccountUpdateInput, Prisma.CreditAccountUncheckedUpdateInput>
  /**
   * Choose, which CreditAccount to update.
   */
  where: Prisma.CreditAccountWhereUniqueInput
}

/**
 * CreditAccount updateMany
 */
export type CreditAccountUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update CreditAccounts.
   */
  data: Prisma.XOR<Prisma.CreditAccountUpdateManyMutationInput, Prisma.CreditAccountUncheckedUpdateManyInput>
  /**
   * Filter which CreditAccounts to update
   */
  where?: Prisma.CreditAccountWhereInput
  /**
   * Limit how many CreditAccounts to update.
   */
  limit?: number
}

/**
 * CreditAccount upsert
 */
export type CreditAccountUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * The filter to search for the CreditAccount to update in case it exists.
   */
  where: Prisma.CreditAccountWhereUniqueInput
  /**
   * In case the CreditAccount found by the `where` argument doesn't exist, create a new CreditAccount with this data.
   */
  create: Prisma.XOR<Prisma.CreditAccountCreateInput, Prisma.CreditAccountUncheckedCreateInput>
  /**
   * In case the CreditAccount was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CreditAccountUpdateInput, Prisma.CreditAccountUncheckedUpdateInput>
}

/**
 * CreditAccount delete
 */
export type CreditAccountDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
  /**
   * Filter which CreditAccount to delete.
   */
  where: Prisma.CreditAccountWhereUniqueInput
}

/**
 * CreditAccount deleteMany
 */
export type CreditAccountDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CreditAccounts to delete
   */
  where?: Prisma.CreditAccountWhereInput
  /**
   * Limit how many CreditAccounts to delete.
   */
  limit?: number
}

/**
 * CreditAccount without action
 */
export type CreditAccountDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CreditAccount
   */
  select?: Prisma.CreditAccountSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CreditAccount
   */
  omit?: Prisma.CreditAccountOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CreditAccountInclude<ExtArgs> | null
}
